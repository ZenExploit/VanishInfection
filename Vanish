local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
   Name = "Vanish Hub",
   LoadingTitle = "Vanish Hub Loading...",
   LoadingSubtitle = "By Zenki",
   ConfigurationSaving = {
      Enabled = true,
      FolderName = Femmy, -- Create a custom folder for your hub/game
      FileName = "Big Hub"
   },
   Discord = {
      Enabled = false,
      Invite = "EPfpgkg6", -- The Discord invite code, do not include discordgg
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },
   KeySystem = true, -- Set this to true to use our key system
   KeySettings = {
      Title = "Vanish Hub",
      Subtitle = "VanishHub Key System",
      Note = "Key is in the Discord!",
      FileName = "Key123", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = false, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key ="VanishInfectionPrem" -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})
local Tab = Window:CreateTab("Main", nil) -- Title, Image
local Section = Tab:CreateSection("Aimbot")
--Aimbot free here below
local predictmovementtoggle = true
local cannotifytoggle = true

local toggleaimlock = false
local AimlockToggle = Tab:CreateToggle({
    Name = "Aimlock",
    CurrentValue = false,
    Flag = "", 
    Callback = function(Value)
    toggleaimlock = Value
    Aimlock = toggleaimlock

getgenv().AimPart = "Head"
getgenv().AimRadius = 100
getgenv().FirstPerson = true 
getgenv().TeamCheck = true
getgenv().PredictMovement = predictmovementtoggle
getgenv().PredictionVelocity = 16 

local Players, Uis, RService, SGui = game:GetService"Players", game:GetService"UserInputService", game:GetService"RunService", game:GetService"StarterGui";
local Client, Mouse, Camera, CF, RNew, Vec3, Vec2 = Players.LocalPlayer, Players.LocalPlayer:GetMouse(), workspace.CurrentCamera, CFrame.new, Ray.new, Vector3.new, Vector2.new;
local Aimlock, MousePressed, CanNotify = true, false, false;
local AimlockTarget;
local aimlockrunservice
getgenv().CiazwareUniversalAimbotLoaded = true

getgenv().SeparateNotify = function(title, text, icon, time) 
    SGui:SetCore("SendNotification",{
        Title = title;
        Text = text;
        Duration = time;
    })
end

getgenv().Notify = function(title, text, icon, time)
    if CanNotify == true then 
        if not time or not type(time) == "number" then time = 3 end
        SGui:SetCore("SendNotification",{
            Title = title;
            Text = text;
            Duration = time;
        }) 
    end
end

getgenv().WorldToViewportPoint = function(P)
    return Camera:WorldToViewportPoint(P)
end

getgenv().WorldToScreenPoint = function(P)
    return Camera.WorldToScreenPoint(Camera, P)
end

getgenv().GetObscuringObjects = function(T)
    if T and T:FindFirstChild(getgenv().AimPart) and Client and Client.Character:FindFirstChild("Head") then 
        local RayPos = workspace:FindPartOnRay(RNew(
            T[getgenv().AimPart].Position, Client.Character.Head.Position)
        )
        if RayPos then return RayPos:IsDescendantOf(T) end
    end
end

getgenv().GetNearestTarget = function()
    -- Credits to whoever made this, i didnt make it, and my own mouse2plr function kinda sucks
    local players = {}
    local PLAYER_HOLD  = {}
    local DISTANCES = {}
    for i, v in pairs(Players:GetPlayers()) do
        if v ~= Client then
            table.insert(players, v)
        end
    end
    for i, v in pairs(players) do
        if v.Character then
            if v.Character:FindFirstChild("Head") and v.Character:FindFirstChild("Humanoid") then
                if v.Character:FindFirstChild("Humanoid").Health > 0 then
                    local AIM = v.Character:FindFirstChild("Head")
                    if getgenv().TeamCheck == true and v.Team ~= Client.Team then
                        local DISTANCE = (v.Character:FindFirstChild("Head").Position - game.Workspace.CurrentCamera.CFrame.p).magnitude
                        local RAY = Ray.new(game.Workspace.CurrentCamera.CFrame.p, (Mouse.Hit.p - game.Workspace.CurrentCamera.CFrame.p).unit * DISTANCE)
                        local HIT,POS = game.Workspace:FindPartOnRay(RAY, game.Workspace)
                        local DIFF = math.floor((POS - AIM.Position).magnitude)
                        PLAYER_HOLD[v.Name .. i] = {}
                        PLAYER_HOLD[v.Name .. i].dist= DISTANCE
                        PLAYER_HOLD[v.Name .. i].plr = v
                        PLAYER_HOLD[v.Name .. i].diff = DIFF
                        table.insert(DISTANCES, DIFF)
                    elseif getgenv().TeamCheck == false and v.Team == Client.Team then 
                        local DISTANCE = (v.Character:FindFirstChild("Head").Position - game.Workspace.CurrentCamera.CFrame.p).magnitude
                        local RAY = Ray.new(game.Workspace.CurrentCamera.CFrame.p, (Mouse.Hit.p - game.Workspace.CurrentCamera.CFrame.p).unit * DISTANCE)
                        local HIT,POS = game.Workspace:FindPartOnRay(RAY, game.Workspace)
                        local DIFF = math.floor((POS - AIM.Position).magnitude)
                        PLAYER_HOLD[v.Name .. i] = {}
                        PLAYER_HOLD[v.Name .. i].dist= DISTANCE
                        PLAYER_HOLD[v.Name .. i].plr = v
                        PLAYER_HOLD[v.Name .. i].diff = DIFF
                        table.insert(DISTANCES, DIFF)
                    end
                end
            end
        end
    end
    
    if unpack(DISTANCES) == nil then
        return nil
    end
    
    local L_DISTANCE = math.floor(math.min(unpack(DISTANCES)))
    if L_DISTANCE > getgenv().AimRadius then
        return nil
    end
    
    for i, v in pairs(PLAYER_HOLD) do
        if v.diff == L_DISTANCE then
            return v.plr
        end
    end
    return nil
end

--[[getgenv().CheckTeamsChildren = function()
    if workspace and workspace:FindFirstChild"Teams" then 
        if getgenv().TeamCheck == true then
            if #workspace.Teams:GetChildren() == 0 then 
                getgenv().TeamCheck = false 
                SeparateNotify("Ciazware", "TeamCheck set to: "..tostring(getgenv().TeamCheck).." because there are no teams!", "", 3)
            end
        end
    end
end
CheckTeamsChildren()
]]--

--[[getgenv().GetNearestTarget = function()
    local T;
    for _, p in next, Players:GetPlayers() do 
        if p ~= Client then 
            if p.Character and p.Character:FindFirstChild(getgenv().AimPart) then 
                if getgenv().TeamCheck == true and p.Team ~= Client.Team then 
                    local Pos, ScreenCheck = WorldToScreenPoint(p.Character[getgenv().AimPart].Position)
                    Pos = Vec2(Pos.X, Pos.Y)
                    local MPos = Vec2(Mouse.X, Mouse.Y) -- Credits to CriShoux for this
                    local Distance = (Pos - MPos).Magnitude;
                    if Distance < getgenv().AimRadius then 
                        T = p 
                    end
                elseif getgenv().TeamCheck == false and p.Team == Client.Team then 
                    local Pos, ScreenCheck = WorldToScreenPoint(p.Character[getgenv().AimPart].Position)
                    Pos = Vec2(Pos.X, Pos.Y)
                    local MPos = Vec2(Mouse.X, Mouse.Y) -- Credits to CriShoux for this
                    local Distance = (Pos - MPos).Magnitude;
                    if Distance < getgenv().AimRadius then 
                        T = p 
                    end
                end
            end
        end
    end
    if T then 
        return T
    end
end]]--

local checkifmouse2button = Uis.InputBegan:Connect(function(Key)
    if not (Uis:GetFocusedTextBox()) then 
        if Key.UserInputType == Enum.UserInputType.MouseButton2 then 
            MousePressed = true 
            local Target;Target = GetNearestTarget()
            if Target ~= nil then 
                print(Target)
                AimlockTarget = Target
                if cannotifytoggle then
                    Notify("Vanish Hub", "Aimlock Target: "..tostring(AimlockTarget), "", 3)
                end
            end   
        end
    end
end)

local checkifmouse2button2 = Uis.InputEnded:Connect(function(Key)
    if Value and toggleaimlock then
        if not (Uis:GetFocusedTextBox()) then 
            if Key.UserInputType == Enum.UserInputType.MouseButton2 then 
                if AimlockTarget ~= nil then AimlockTarget = nil end
                if MousePressed ~= false then 
                    MousePressed = false 
                end
            end
        end
    else
        if checkifmouse2button then
            checkifmouse2button:Disconnect()
            checkifmouse2button = nil
        end
    end
end)

if Value then
    aimlockrunservice = RService.RenderStepped:Connect(function()
        getgenv().PredictMovement = predictmovementtoggle 
        if toggleaimlock and Value then
            if getgenv().FirstPerson == true then 
                if 0 == 0 then 
                    CanNotify = true 
                else 
                    CanNotify = false
                end
            end
            if Aimlock == true and MousePressed == true then 
                if AimlockTarget and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(getgenv().AimPart) then 
                    if getgenv().FirstPerson == true then
                        if CanNotify == true then
                            if getgenv().PredictMovement == true then 
                                if AimlockTarget then
                                    if AimlockTarget.Character then
                                        if AimlockTarget.Character:FindFirstChild(getgenv().AimPart) then
                                            Camera.CFrame = CF(Camera.CFrame.p, AimlockTarget.Character[getgenv().AimPart].Position + AimlockTarget.Character[getgenv().AimPart].Velocity/PredictionVelocity)
                                        end
                                    end
                                end
                            elseif getgenv().PredictMovement == false then 
                                if AimlockTarget then
                                    if AimlockTarget.Character then
                                        if AimlockTarget.Character:FindFirstChild(getgenv().AimPart) then
                                            Camera.CFrame = CF(Camera.CFrame.p, AimlockTarget.Character[getgenv().AimPart].Position)
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        else
            if aimlockrunservice then
                aimlockrunservice:Disconnect()
            end
        end
    end)
else
    if not Value and not toggleaimlock then 
        if aimlockrunservice then
            aimlockrunservice:Disconnect()
        end
        if checkifmouse2button then
            checkifmouse2button:Disconnect()
            checkifmouse2button = nil
        end
        if checkifmouse2button2 then
            checkifmouse2button2:Disconnect()
            checkifmouse2button2 = nil
        end
    end
end

end,
})

local predictmovementtogglechanger = Tab:CreateToggle({
   Name = "Predict movement",
   CurrentValue = true,
   Flag = "", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(v)
        predictmovementtoggle = v
   end,
})

local cannotifytogglechanger = Tab:CreateToggle({
   Name = "Notify aimlock's target",
   CurrentValue = true,
   Flag = "",
   Callback = function(v)
    cannotifytoggle = v
   end,
})
--All esp's
-- Create section for Player ESP settings
local Section1 = Tab:CreateSection("Player ESP")

-- Initialize default values
local textSize = 14
local currentColor = Color3.fromRGB(255, 255, 255)
local isVisible = false -- Initially turned off
local showHealth = false
local rainbowText = false
local highlightPlayers = false
local highlightTransparency = 0.5

-- Create Toggle for showing player names
local Toggle = Tab:CreateToggle({
    Name = "Player ESP",
    CurrentValue = isVisible,  -- Default value (false = disabled initially)
    Flag = "Toggle1", -- Identifier for the configuration file
    Callback = function(Value)
        isVisible = Value
        -- Toggle visibility of player names based on the toggle state
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character and player.Character:FindFirstChild("Head") then
                local billboard = player.Character.Head:FindFirstChild("UsernameBillboard")
                if billboard then
                    billboard.Enabled = Value
                    local textLabel = billboard:FindFirstChild("InfoLabel")
                    if textLabel then
                        textLabel.Visible = Value
                    end
                end
            end
        end
    end,
})

-- Create a new section for additional settings
local Section2 = Tab:CreateSection("Settings")

-- Create Toggle for showing player health
local HealthToggle = Tab:CreateToggle({
    Name = "Show Health",
    CurrentValue = showHealth,  -- Default value (false = disabled initially)
    Flag = "Toggle2", -- Identifier for the configuration file
    Callback = function(Value)
        showHealth = Value
        -- Update health display in all existing billboards
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character and player.Character:FindFirstChild("Head") then
                local billboard = player.Character.Head:FindFirstChild("UsernameBillboard")
                if billboard then
                    local textLabel = billboard:FindFirstChild("InfoLabel")
                    if textLabel then
                        textLabel.Text = showHealth and ("Name: " .. player.Name .. " | Health: " .. math.floor(player.Character.Humanoid.Health)) or ("Name: " .. player.Name)
                    end
                end
            end
        end
    end,
})

-- Create Toggle for Highlight
local HighlightToggle = Tab:CreateToggle({
    Name = "Highlight",
    CurrentValue = highlightPlayers,  -- Default value (false = disabled initially)
    Flag = "Toggle4", -- Identifier for the configuration file
    Callback = function(Value)
        highlightPlayers = Value
        -- Apply or remove highlight effect based on the toggle state
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character then
                local character = player.Character
                local highlight = character:FindFirstChild("Highlight")

                if highlightPlayers then
                    if not highlight then
                        highlight = Instance.new("Highlight")
                        highlight.Name = "Highlight"
                        highlight.Adornee = character
                        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                        highlight.Parent = character
                    end
                    -- Set highlight color and transparency
                    highlight.OutlineColor = rainbowText and Color3.fromHSV(tick() % 360 / 360, 1, 1) or currentColor
                    highlight.FillColor = highlight.OutlineColor
                    highlight.FillTransparency = highlightTransparency
                else
                    if highlight then
                        highlight:Destroy()
                    end
                end
            end
        end
    end,
})

-- Create Toggle for rainbow text effect
local RainbowToggle = Tab:CreateToggle({
    Name = "Rainbow Text",
    CurrentValue = rainbowText,  -- Default value (false = disabled initially)
    Flag = "Toggle3", -- Identifier for the configuration file
    Callback = function(Value)
        rainbowText = Value
        -- Update the color of the highlight based on the rainbow effect
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character then
                local character = player.Character
                local highlight = character:FindFirstChild("Highlight")
                if highlight then
                    highlight.OutlineColor = rainbowText and Color3.fromHSV(tick() % 360 / 360, 1, 1) or currentColor
                    highlight.FillColor = highlight.OutlineColor
                end
            end
        end

        -- Update text color in all billboards
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character and player.Character:FindFirstChild("Head") then
                local billboard = player.Character.Head:FindFirstChild("UsernameBillboard")
                if billboard then
                    local textLabel = billboard:FindFirstChild("InfoLabel")
                    if textLabel then
                        -- Start coroutine to update text color in a rainbow effect
                        if rainbowText then
                            coroutine.wrap(function()
                                while rainbowText do
                                    for i = 1, 360, 10 do
                                        local hue = i / 360
                                        textLabel.TextColor3 = Color3.fromHSV(hue, 1, 1)
                                        wait(0.1)
                                    end
                                end
                            end)()
                        else
                            textLabel.TextColor3 = currentColor
                        end
                    end
                end
            end
        end
    end,
})

-- Create Color Picker
local ColorPicker = Tab:CreateColorPicker({
    Name = "Text Color Picker",
    Color = currentColor, -- Default color (white)
    Flag = "ColorPicker1", -- Identifier for the configuration file
    Callback = function(Value)
        currentColor = Value
        -- Change the color of the text in all BillboardGui instances
        if not rainbowText then
            for _, player in pairs(game.Players:GetPlayers()) do
                if player.Character and player.Character:FindFirstChild("Head") then
                    local billboard = player.Character.Head:FindFirstChild("UsernameBillboard")
                    if billboard then
                        local textLabel = billboard:FindFirstChild("InfoLabel")
                        if textLabel then
                            textLabel.TextColor3 = Value
                        end
                    end
                end
            end
        end

        -- Change the color of the highlight in all characters
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character then
                local character = player.Character
                local highlight = character:FindFirstChild("Highlight")
                if highlight then
                    highlight.OutlineColor = rainbowText and Color3.fromHSV(tick() % 360 / 360, 1, 1) or currentColor
                    highlight.FillColor = highlight.OutlineColor
                end
            end
        end
    end,
})

-- Create Slider for text size
local Slider = Tab:CreateSlider({
    Name = "Text Size",
    Range = {10, 20},
    Increment = 1,
    Suffix = "Size",
    CurrentValue = textSize,
    Flag = "Slider1", -- Identifier for the configuration file
    Callback = function(Value)
        textSize = Value
        -- Update text size in all existing billboards
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character and player.Character:FindFirstChild("Head") then
                local billboard = player.Character.Head:FindFirstChild("UsernameBillboard")
                if billboard then
                    local textLabel = billboard:FindFirstChild("InfoLabel")
                    if textLabel then
                        textLabel.TextSize = textSize
                    end
                end
            end
        end
    end,
})

-- Create Slider for highlight fill transparency
local TransparencySlider = Tab:CreateSlider({
    Name = "Highlight Fill Transparency",
    Range = {0, 1},
    Increment = 0.05,
    Suffix = "Transparency",
    CurrentValue = highlightTransparency,
    Flag = "Slider2", -- Identifier for the configuration file
    Callback = function(Value)
        highlightTransparency = Value
        -- Update fill transparency in all existing highlights
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character then
                local character = player.Character
                local highlight = character:FindFirstChild("Highlight")
                if highlight then
                    highlight.FillTransparency = highlightTransparency
                end
            end
        end
    end,
})

-- Function to create the BillboardGui
local function createBillboard(player)
    -- Avoid creating a BillboardGui for the local player
    if player == game.Players.LocalPlayer then
        return
    end

    local character = player.Character
    if not character then return end

    local head = character:WaitForChild("Head")
    if not head then return end

    -- Check if BillboardGui already exists
    local existingBillboard = head:FindFirstChild("UsernameBillboard")
    if existingBillboard then
        existingBillboard:Destroy()
    end

    -- Create BillboardGui
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "UsernameBillboard"
    billboard.Adornee = head
    billboard.Size = UDim2.new(6, 0, 1, 0)  -- Adjust the size as needed for longer usernames
    billboard.StudsOffset = Vector3.new(0, 3, 0)  -- Offset from the head
    billboard.AlwaysOnTop = true
    billboard.Enabled = isVisible  -- Set initial visibility based on the toggle

    -- Create TextLabel for username and health
    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "InfoLabel"
    textLabel.Parent = billboard
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = currentColor
    textLabel.TextStrokeTransparency = 0.5
    textLabel.Font = Enum.Font.SourceSansBold
    textLabel.TextSize = textSize
    textLabel.TextWrapped = false
    textLabel.TextTruncate = Enum.TextTruncate.None
    textLabel.Text = showHealth and ("Name: " .. player.Name .. " | Health: " .. math.floor(character.Humanoid.Health)) or ("Name: " .. player.Name)

    -- Parent the BillboardGui to the character's head
    billboard.Parent = head

    -- Update health label when health changes
    if showHealth then
        character.Humanoid.HealthChanged:Connect(function()
            if textLabel then
                textLabel.Text = "Name: " .. player.Name .. " | Health: " .. math.floor(character.Humanoid.Health)
            end
        end)
    end

    -- Apply highlight if enabled
    if highlightPlayers then
        local highlight = character:FindFirstChild("Highlight")
        if not highlight then
            highlight = Instance.new("Highlight")
            highlight.Name = "Highlight"
            highlight.Adornee = character
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Parent = character
        end
        -- Set highlight color and transparency
        highlight.OutlineColor = rainbowText and Color3.fromHSV(tick() % 360 / 360, 1, 1) or currentColor
        highlight.FillColor = highlight.OutlineColor
        highlight.FillTransparency = highlightTransparency
    end
end

-- Function to handle player addition
local function onPlayerAdded(player)
    -- Wait for the character to load
    player.CharacterAdded:Connect(function(character)
        -- Create the BillboardGui when the character spawns
        createBillboard(player)
    end)
end

-- Loop through all existing players
for _, player in pairs(game.Players:GetPlayers()) do
    -- Create BillboardGui for each player
    createBillboard(player)
    -- Connect to CharacterAdded event in case the character respawns
    player.CharacterAdded:Connect(function()
        createBillboard(player)
    end)
end

-- Connect the PlayerAdded event
game.Players.PlayerAdded:Connect(onPlayerAdded)



local Section = Tab:CreateSection("Other ESP's")

local lplr = game.Players.LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera
local RunService = game:GetService("RunService")

local Tracers = {}
local TracerEnabled = false -- This will be controlled by the toggle

-- Function to create a tracer for a player
local function createTracer(player)
    local Tracer = Drawing.new("Line")
    Tracer.Visible = false
    Tracer.Color = Color3.new(1, 1, 1)
    Tracer.Thickness = 1
    Tracer.Transparency = 1
    Tracers[player.UserId] = Tracer
end

-- Function to update tracers
local function updateTracers()
    if not TracerEnabled then
        for _, tracer in pairs(Tracers) do
            tracer.Visible = false
        end
        return
    end

    for _, player in pairs(game.Players:GetPlayers()) do
        local tracer = Tracers[player.UserId]
        if not tracer then
            createTracer(player)
            tracer = Tracers[player.UserId]
        end

        if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character:FindFirstChild("HumanoidRootPart") and player ~= lplr and player.Character.Humanoid.Health > 0 then
            local Vector, OnScreen = camera:worldToViewportPoint(player.Character.HumanoidRootPart.Position)

            if OnScreen then
                tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                tracer.To = Vector2.new(Vector.X, Vector.Y)

                if _G.TeamCheck and player.TeamColor == lplr.TeamColor then
                    tracer.Visible = false
                else
                    tracer.Visible = true
                end
            else
                tracer.Visible = false
            end
        else
            tracer.Visible = false
        end
    end
end

-- Connection to update tracers every frame
RunService.RenderStepped:Connect(updateTracers)

-- Handle player added and removed
game.Players.PlayerAdded:Connect(function(player)
    createTracer(player)
end)

game.Players.PlayerRemoving:Connect(function(player)
    if Tracers[player.UserId] then
        Tracers[player.UserId]:Remove()
        Tracers[player.UserId] = nil
    end
end)

-- Initial tracer creation for existing players
for _, player in pairs(game.Players:GetPlayers()) do
    createTracer(player)
end

-- Toggle creation and callback
local Toggle = Tab:CreateToggle({
    Name = "Toggle Tracers",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file
    Callback = function(Value)
        TracerEnabled = Value
        -- Optionally update tracers immediately when toggle is changed
        updateTracers()
    end,
})

local Button = Tab:CreateButton({
   Name = "Player detection (Stays until leave)",
   Callback = function()
loadstring(game:HttpGet("https://pastebin.com/raw/arVatYFs",true))()
   end,
})
--All esp's end here
local Tab = Window:CreateTab("Misc", nil) -- Title, Image
local Section = Tab:CreateSection("Strafe")
-- Variables
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local strafeRadius = 4 -- Default radius of strafing around the target player
local strafeSpeed = 5 -- Default speed of strafing around the target player
local isActive = false -- Control the state of the toggle
local targetPlayer = nil -- The player currently being followed
local connection -- Store the RenderStepped connection

-- Function to find the nearest player
local function findNearestPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge -- Start with an infinitely large distance

    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (player.Character.HumanoidRootPart.Position - otherPlayer.Character.HumanoidRootPart.Position).magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                closestPlayer = otherPlayer
            end
        end
    end

    return closestPlayer
end

-- Function to strafe around the target player
local function strafeAroundPlayer()
    if connection then
        connection:Disconnect() -- Disconnect any previous connections
    end

    local angle = 0
    connection = RunService.RenderStepped:Connect(function(deltaTime)
        if isActive and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local targetHumanoidRootPart = targetPlayer.Character.HumanoidRootPart
            local centerPosition = targetHumanoidRootPart.Position

            -- Update angle for strafing movement
            angle = angle + (strafeSpeed * deltaTime)
            local xOffset = strafeRadius * math.cos(angle)
            local zOffset = strafeRadius * math.sin(angle)

            -- Position the character to strafe around the target player
            player.Character.HumanoidRootPart.CFrame = CFrame.new(centerPosition + Vector3.new(xOffset, 0, zOffset), centerPosition)

            -- Disable player movement
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.PlatformStand = true
            end

            -- Check target player's health
            local targetHumanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
            if targetHumanoid and targetHumanoid.Health < 15 then
                isActive = false -- Stop following if the player is below 15 health
                targetPlayer = nil
                print("Target player's health is below 15. Stopping.")
            end
        else
            -- Re-enable movement when toggle is off or no valid target
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.PlatformStand = false
            end
            if connection then
                connection:Disconnect() -- Stop strafing when toggle is off
                connection = nil
            end
        end
    end)
end

-- Create Toggle for Strafing Around Nearest Player
local Toggle = Tab:CreateToggle({
    Name = "Strafe Around Nearest Player",
    CurrentValue = false,
    Flag = "Toggle1", -- Unique flag for configuration saving
    Callback = function(Value)
        isActive = Value
        print("Strafing around nearest player:", isActive)
        if isActive then
            targetPlayer = findNearestPlayer() -- Set the target player
            if targetPlayer then
                strafeAroundPlayer()
            else
                isActive = false
                print("No valid target player found.")
            end
        else
            if connection then
                connection:Disconnect() -- Stop strafing when toggle is off
                connection = nil
            end
        end
    end,
})

-- Create Slider for Strafe Radius
local RadiusSlider = Tab:CreateSlider({
    Name = "Strafe Radius",
    Range = {1, 10},
    Increment = 1,
    Suffix = "Units",
    CurrentValue = strafeRadius,
    Flag = "RadiusSlider", -- Unique flag for configuration saving
    Callback = function(Value)
        strafeRadius = Value
        print("Strafe radius set to:", strafeRadius)
    end,
})

-- Create Slider for Strafe Speed
local SpeedSlider = Tab:CreateSlider({
    Name = "Strafe Speed",
    Range = {1, 10},
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = strafeSpeed,
    Flag = "SpeedSlider", -- Unique flag for configuration saving
    Callback = function(Value)
        strafeSpeed = Value
        print("Strafe speed set to:", strafeSpeed)
    end,
})

-- Handle respawns
player.CharacterAdded:Connect(function(character)
    -- Wait for the character to load properly
    character:WaitForChild("HumanoidRootPart")
    if isActive then
        targetPlayer = findNearestPlayer() -- Reassign the target player on respawn
        if targetPlayer then
            strafeAroundPlayer()
        end
    end
end)

print("Strafe script with toggle and sliders loaded")

--strafe end here
local Section = Tab:CreateSection("FollowPlayer")
-- Slider for follow distance
local followDistance = 3 -- Default value
local FollowDistanceSlider = Tab:CreateSlider({
    Name = "Follow Distance",
    Range = {1, 5},  -- Set the range from 1 to 5
    Increment = 0.1,  -- Set the increment to 0.1
    Suffix = "Units",  -- Optional: Adds a suffix to the slider value
    CurrentValue = followDistance,  -- Default value of the slider
    Flag = "Slider1",  -- Unique identifier for the configuration file
    Callback = function(Value)
        followDistance = Value
    end,
})

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local isFollowing = false
local updateInterval = 0.001
local followPlayer = nil

-- Function to handle respawning
local function onCharacterAdded(newCharacter)
    character = newCharacter
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
end

player.CharacterAdded:Connect(onCharacterAdded)

-- Function to position the player behind the nearest player
local function positionBehindNearestPlayer()
    local nearestPlayer = nil
    local nearestDistance = math.huge

    -- Find the nearest player
    for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local otherHRP = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            local humanoid = otherPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health >= 15 then
                local distance = (humanoidRootPart.Position - otherHRP.Position).magnitude
                if distance < nearestDistance then
                    nearestDistance = distance
                    nearestPlayer = otherPlayer
                end
            end
        end
    end

    if nearestPlayer then
        followPlayer = nearestPlayer
        local otherHRP = nearestPlayer.Character:FindFirstChild("HumanoidRootPart")
        local behindPosition = otherHRP.Position - otherHRP.CFrame.LookVector * followDistance
        humanoidRootPart.CFrame = CFrame.new(behindPosition, otherHRP.Position)
    end
end

-- Function to position the player on top of the nearest player's head
local function positionOnTopOfPlayerHead()
    if followPlayer and followPlayer.Character and followPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local otherHRP = followPlayer.Character:FindFirstChild("HumanoidRootPart")
        local head = followPlayer.Character:FindFirstChild("Head")
        if head then
            humanoidRootPart.CFrame = CFrame.new(head.Position + Vector3.new(0, 3, 0), otherHRP.Position)
        end
    end
end

-- Toggle to enable/disable the feature
local Toggle = Tab:CreateToggle({
    Name = "Enable Follow from Behind",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
        if Value then
            isFollowing = true
            while isFollowing do
                if followPlayer and followPlayer.Character and followPlayer.Character:FindFirstChildOfClass("Humanoid") then
                    local humanoid = followPlayer.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health < 15 then
                        -- Stop following and position on top of the player's head
                        isFollowing = false
                        positionOnTopOfPlayerHead()
                    else
                        -- Continue following
                        positionBehindNearestPlayer()
                    end
                else
                    -- No valid followPlayer, find the nearest player
                    positionBehindNearestPlayer()
                end
                wait(updateInterval)
            end
        else
            isFollowing = false
        end
    end
})

-- Function to keep the player behind the nearest player while the feature is enabled
game:GetService("RunService").RenderStepped:Connect(function()
    if isFollowing and followPlayer then
        if followPlayer.Character and followPlayer.Character:FindFirstChildOfClass("Humanoid") then
            local humanoid = followPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health < 15 then
                -- Stop following and position on top of the player's head
                isFollowing = false
                positionOnTopOfPlayerHead()
            else
                -- Continue following
                positionBehindNearestPlayer()
            end
        end
    end
end)
local Section = Tab:CreateSection("Bang")

-- Set default follow distance and range
local followDistance = 3
local minDistance = 1.3
local maxDistance = 4

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local isFollowing = false
local followPlayer = nil
local distanceFlowing = false
local flowDirection = 1
local speed = 0.1 -- Default speed

-- Create and configure the Sound objects
local sound1 = Instance.new("Sound")
sound1.SoundId = "rbxassetid://6892830182"
sound1.Volume = 1
sound1.Parent = character

local sound2 = Instance.new("Sound")
sound2.SoundId = "rbxassetid://9125702141"
sound2.Volume = 1
sound2.Parent = character

-- Function to handle respawning
local function onCharacterAdded(newCharacter)
    character = newCharacter
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    sound1.Parent = character
    sound2.Parent = character
end

player.CharacterAdded:Connect(onCharacterAdded)

-- Function to position the player behind the followPlayer
local function positionBehindFollowPlayer()
    if followPlayer and followPlayer.Character and followPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local otherHRP = followPlayer.Character:FindFirstChild("HumanoidRootPart")
        local behindPosition = otherHRP.Position - otherHRP.CFrame.LookVector * followDistance
        humanoidRootPart.CFrame = CFrame.new(behindPosition, otherHRP.Position)
    end
end

-- Function to position the player on top of the followPlayer's head
local function positionOnTopOfPlayerHead()
    if followPlayer and followPlayer.Character and followPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local otherHRP = followPlayer.Character:FindFirstChild("HumanoidRootPart")
        local head = followPlayer.Character:FindFirstChild("Head")
        if head then
            humanoidRootPart.CFrame = CFrame.new(head.Position + Vector3.new(0, 3, 0), otherHRP.Position)
        end
    end
end

-- Toggle to enable/disable the feature
local Toggle = Tab:CreateToggle({
    Name = "Bang",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
        if Value then
            isFollowing = true
            distanceFlowing = true
            -- Find and set the followPlayer
            local nearestPlayer = nil
            local nearestDistance = math.huge
            for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
                if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local otherHRP = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local humanoid = otherPlayer.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health >= 15 then
                        local distance = (humanoidRootPart.Position - otherHRP.Position).magnitude
                        if distance < nearestDistance then
                            nearestDistance = distance
                            nearestPlayer = otherPlayer
                        end
                    end
                end
            end
            followPlayer = nearestPlayer
            
            -- Coroutine for flowing distance
            coroutine.wrap(function()
                while distanceFlowing do
                    if isFollowing then
                        followDistance = followDistance + (speed * flowDirection) -- Adjust increment based on speed
                        if followDistance >= maxDistance then
                            followDistance = maxDistance
                            flowDirection = -1
                        elseif followDistance <= minDistance then
                            followDistance = minDistance
                            flowDirection = 1
                            sound2:Play() -- Play sound when the distance reaches 1.3 units
                            sound1:Play()
                        end
                    end
                    wait(0.001) -- Decrease the wait time for smoother and faster transitions
                end
            end)()
        else
            isFollowing = false
            distanceFlowing = false
        end
    end
})

-- Slider to control the speed of the flowing distance
local Slider = Tab:CreateSlider({
    Name = "Bang Speed",
    Range = {0.1, 1}, -- Set a reasonable range for speed
    Increment = 0.1, -- Set the increment to 0.1 for precise control
    Suffix = "Speed", -- Optional: Adds a suffix to the slider value
    CurrentValue = speed, -- Default value of the slider
    Flag = "Slider1", -- Unique identifier for the configuration file
    Callback = function(Value)
        speed = Value -- Adjust speed multiplier as needed
    end,
})

-- Update the playerâ€™s position based on the toggle state
game:GetService("RunService").RenderStepped:Connect(function()
    if isFollowing then
        if followPlayer and followPlayer.Character and followPlayer.Character:FindFirstChildOfClass("Humanoid") then
            local humanoid = followPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health < 15 then
                -- Stop following and position on top of the player's head
                isFollowing = false
                positionOnTopOfPlayerHead()
            else
                -- Continue following
                positionBehindFollowPlayer()
            end
        else
            -- No valid followPlayer, stop following
            isFollowing = false
        end
    end
end)

local Section = Tab:CreateSection("Spin")
-- Variables for spinning
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

-- Initialize spin speed and status
local spinSpeed = 30 -- Default spin speed
local spinning = false -- Control spinning status

-- Function to initialize spinning logic
local function initializeSpinning()
    -- Wait until the character and parts are fully loaded
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    local humanoid = character:WaitForChild("Humanoid")
    local angle = 0

    print("Initializing spinning logic...")

    -- Function to handle spinning
    local connection
    connection = RunService.RenderStepped:Connect(function(deltaTime)
        if spinning then
            angle = angle + (spinSpeed * deltaTime)
            humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position) * CFrame.Angles(0, angle, 0)
        end
        
        -- Check if health is below 15 and stop spinning if so
        if humanoid.Health < 15 then
            spinning = false
        end
    end)

    -- Disconnect the connection on character removal
    character.AncestryChanged:Connect(function(_, parent)
        if not parent then
            connection:Disconnect()
        end
    end)
end

-- Function to handle character respawn
local function onCharacterAdded(character)
    print("Character added, initializing spinning...")
    -- Wait for HumanoidRootPart to be available
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    -- Ensure initialization of spinning logic
    initializeSpinning()
end

-- Connect to CharacterAdded to handle respawn
player.CharacterAdded:Connect(onCharacterAdded)

-- Initialize spinning for the current character if already loaded
if player.Character then
    onCharacterAdded(player.Character)
end

-- Create Toggle for Spin Control
local Toggle = Tab:CreateToggle({
    Name = "Spin Toggle",
    CurrentValue = false,
    Flag = "Toggle1", -- Unique flag for configuration saving
    Callback = function(Value)
        spinning = Value
        print("Spinning set to:", spinning)
    end,
})

-- Create Slider for Spin Speed
local Slider = Tab:CreateSlider({
    Name = "Spin Speed",
    Range = {1, 100}, -- Minimum and maximum values for spin speed
    Increment = 1,
    Suffix = "degrees/sec", -- Display suffix for the slider value
    CurrentValue = spinSpeed, -- Initial value of the slider
    Flag = "Slider1", -- Unique flag for configuration saving
    Callback = function(Value)
        spinSpeed = Value
        print("Spin speed set to:", spinSpeed)
    end,
})

-- Ensure the spinning starts
print("Script is running")

local Section = Tab:CreateSection("Movement")
local speedslider = 1.1
local togglespeed = false
local Speedtoggle = Tab:CreateToggle({
    Name = "Speed",
    CurrentValue = false,
    Flag = "", 
    Callback = function(Value)
    togglespeed = Value

        getgenv().Speed = speedslider

        local speaker = game:GetService("Players").LocalPlayer
        local chr = speaker.Character
        local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
        local hb = game:GetService("RunService").Heartbeat
        if Value then
            while togglespeed and chr and hum and hum.Parent do
                wait()
                if togglespeed and Value then
                    getgenv().Speed = speedslider
                    if speaker.Character and speaker.Character:FindFirstChildWhichIsA("Humanoid") then 
                        chr = speaker.Character
                    end
                    local delta = hb:Wait()
                    if hum.MoveDirection.Magnitude > 0 then
                        chr:TranslateBy(hum.MoveDirection * tonumber(getgenv().Speed) * delta * 10)
                    else
                        chr:TranslateBy(hum.MoveDirection * delta * 10)
                    end
                end
            end
        end
end,
})

local speedsliderchanger = Tab:CreateSlider({
   Name = "Speed",
   Range = {1, 7},
   Increment = 0.1,
   Suffix = "Speed",
   CurrentValue = 1.1,
   Flag = "", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(v)
    speedslider = v
   end,
})
local Slider = Tab:CreateSlider({
   Name = "Gravity (196 Normal 75 is highest jump)",
   Range = {196, 75},
   Increment = 1,
   Suffix = "Gravity",
   CurrentValue = 196.2,
   Flag = "SliderGravity", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
workspace.Gravity = (Value)
   end,
})
local repStorage = game:GetService("ReplicatedStorage")
local valuesFolder = repStorage:FindFirstChild("Values")
local FinishSpeedMult = valuesFolder:FindFirstChild("FinishSpeedMulti")

local Section = Tab:CreateSection("Vision")
local Slider = Tab:CreateSlider({
   Name = "Custom Day Time",
   Range = {1, 24},
   Increment = 1,
   Suffix = ": 00",
   CurrentValue = 12,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
local repStorage = game:GetService("ReplicatedStorage")
    local valuesFolder = repStorage:FindFirstChild("Values")

    local TimeState = valuesFolder:FindFirstChild("TimeState")
    TimeState.Value = (Value)
    TimeState.Enabled.Value = true
   end,
})
local Slider = Tab:CreateSlider({
   Name = "Max CameraZoom Distance",
   Range = {10, 250},
   Increment = 2,
   Suffix = "Distance",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
game.Players.LocalPlayer.CameraMaxZoomDistance = Value
   end,
})
local Dropdown = Tab:CreateDropdown({
   Name = "Camera Mode",
   Options = {"Zoom","Invisicam"},
   CurrentOption = {"Zoom"},
   MultipleOptions = false,
   Flag = "Dropdown1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Option)
for _, option in Option do
game.Players.LocalPlayer.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode[option]
end
   end,
})
-- Function to create and set up the ScreenGui and ImageLabel
local function createCrosshair()
    -- Create a ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ExampleGui"
    screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

    -- Create an ImageLabel (initially hidden)
    local imageLabel = Instance.new("ImageLabel")
    imageLabel.Name = "ExampleImage"
    imageLabel.Size = UDim2.new(0.03, 0, 0.03, 0) -- Set size to 3% width and height of the screen (smaller crosshair size)
    imageLabel.Position = UDim2.new(0.5, 0, 0.4775, 0) -- Centered horizontally, positioned in between the old and new vertical positions
    imageLabel.AnchorPoint = Vector2.new(0.5, 0.5) -- Center anchor
    imageLabel.Image = "rbxassetid://1827745860" -- Updated image ID
    imageLabel.BackgroundTransparency = 1 -- Transparent background
    imageLabel.Visible = false -- Initially hidden
    imageLabel.Parent = screenGui
end

-- Create initial crosshair
createCrosshair()

-- Recreate crosshair on respawn
game.Players.LocalPlayer.CharacterAdded:Connect(function()
    -- Remove old ScreenGui if it exists
    local oldGui = game.Players.LocalPlayer.PlayerGui:FindFirstChild("ExampleGui")
    if oldGui then
        oldGui:Destroy()
    end
    -- Create new crosshair
    createCrosshair()
end)

-- Create a toggle using 'Tab:CreateToggle'
local Toggle = Tab:CreateToggle({
    Name = "Crosshair", -- Renamed the toggle
    CurrentValue = false, -- Initial state of the toggle
    Flag = "Toggle1", -- Unique flag for configuration
    Callback = function(Value)
        -- Toggle the visibility of the image based on the toggle value
        local imageLabel = game.Players.LocalPlayer.PlayerGui:FindFirstChild("ExampleGui") and game.Players.LocalPlayer.PlayerGui.ExampleGui:FindFirstChild("ExampleImage")
        if imageLabel then
            imageLabel.Visible = Value
        end
    end,
})
local Section = Tab:CreateSection("Chat")
local Button2 = Tab:CreateButton({
   Name = "Chat Spy",
   Callback = function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/LisSploit/FemboysHubChat/main/Spy"))()
   end,
})
local Section = Tab:CreateSection("Combat")
local Button3 = Tab:CreateButton({
   Name = "WallBang",
   Callback = function()
        game:service[[Workspace]]:FindFirstChild('Map'):FindFirstChild('Parts'):FindFirstChild('M_Parts').Parent =
game:service[[Workspace]]:FindFirstChild('Characters')
   end,
})
local Button3 = Tab:CreateButton({
   Name = "Admin Protection (Auto leave when Staff joins the server)",
   Callback = function()
local blacklist = {"tabootvcat", "Revenantic", "Saabor", "MoIitor", "IAmUnderAMask", "SheriffGorji", "xXFireyScorpionXx", "LoChips", "DeliverCreations", "TDXiswinning", "TZZV", "FelixVenue", "SIEGFRlED", "ARRYvvv", "z_papermoon", "Malpheasance", "ModHandIer", "valphex", "J_anday", "tvdisko", "yIlehs", "DeliverCreations", "COLOSSUSBUILTOFSTEEL", "SeizedHolder", "r3shape", "RVVZ", "adurize", "codedcosmetics", "QuantumCaterpillar", "FractalHarmonics", "GalacticSculptor", "oTheSilver", "Kretacaous", "icarus_xs1goliath", "GlamorousDradon", "rainjeremy", "parachuter2000", "faintermercury", "harht", "Sansek1252", "Snorpuwu", "BenAzoten", "Cand1ebox", "KeenlyAware", "mrzued", "BruhmanVIII", "Nystesia", "fausties", "zateopp", "Iordnabi", "ReviveTheDevil", "jake_jpeg", "UncrossedMeat3888", "realpenyy", "karateeeh", "JayyMlg", "Lo_Chips", "Avelosky", "king_ab09", "TigerLe123", "Dalvanuis", "MoIitor", "FelixVenue", "iSonMillions"}

-- Convert blacklist to lowercase for consistent comparison
for i = 1, #blacklist do
    blacklist[i] = string.lower(blacklist[i])
end

local function checkPlayer(player)
    if table.find(blacklist, string.lower(player.Name)) then
        game.Players.LocalPlayer:Kick("Stinky Staff joined the server - Femboyshub")
    end
end

local function check()
    for _, player in ipairs(game.Players:GetPlayers()) do
        checkPlayer(player)
    end
end

-- Connect to the PlayerAdded event to check for new players joining the game
game.Players.PlayerAdded:Connect(checkPlayer)

-- Run the check function initially to cover players already in the game
check()
   end,
})
local Button = Tab:CreateButton({
   Name = "RPG-7 rocket control",
   Callback = function()
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local CurrentCamera = workspace.CurrentCamera
local Debris = workspace.Debris
local VParts = Debris.VParts

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local Forward = 0
local Sideways = 0
local RocketSpeed = 300
local Break = false

VParts.ChildAdded:Connect(function(RPG_Rocket)
    if not Players.LocalPlayer.Character:FindFirstChild("RPG-7") then
        return
    end
    
    task.wait()

    if RPG_Rocket.Name == "RPG_Rocket" then
        CurrentCamera.CameraSubject = RPG_Rocket

        LocalPlayer.Character.HumanoidRootPart.Anchored = true

        pcall(function()
            RPG_Rocket.BodyForce:Destroy()
            RPG_Rocket.RotPart.BodyAngularVelocity:Destroy()
            RPG_Rocket.Sound:Destroy()
        end)
        
        local BV = Instance.new("BodyVelocity", RPG_Rocket)
        BV.MaxForce = Vector3.new(1e9, 1e9, 1e9)
        BV.Velocity = Vector3.new()
        
        local BG = Instance.new("BodyGyro", RPG_Rocket)
        BG.P = 9e4
        BG.MaxTorque = Vector3.new(1e9, 1e9, 1e9)

        task.spawn(function()
            while true do
                RunService.RenderStepped:Wait()

                TweenService:Create(BV, TweenInfo.new(0.2), {Velocity = ((CurrentCamera.CFrame.LookVector * Forward) + (CurrentCamera.CFrame.RightVector * Sideways)) * RocketSpeed}):Play()
                BG.CFrame = CurrentCamera.CoordinateFrame
                workspace.CurrentCamera.CFrame = RPG_Rocket.CFrame * CFrame.new(Vector3.new(0, 1, 1))
                
                if Break then
                    Break = false
                    break
                end
            end
            
            CurrentCamera.CameraSubject = LocalPlayer.Character.Humanoid
            LocalPlayer.Character.HumanoidRootPart.Anchored = false
        end)    

        UserInputService.InputBegan:Connect(function(Key)
            if Key.KeyCode == Enum.KeyCode.W then
                Forward = 1
            elseif Key.KeyCode == Enum.KeyCode.S then
                Forward = -1
            elseif Key.KeyCode == Enum.KeyCode.D then
                Sideways = 1
            elseif Key.KeyCode == Enum.KeyCode.A then
                Sideways = -1
            end
        end)

        UserInputService.InputEnded:Connect(function(Key)
            if Key.KeyCode == Enum.KeyCode.W or Key.KeyCode == Enum.KeyCode.S then
                Forward = 0
            elseif Key.KeyCode == Enum.KeyCode.D or Key.KeyCode == Enum.KeyCode.A then
                Sideways = 0
            end
        end)
    end
end)

Debris.ChildAdded:Connect(function(A)
    task.wait()
    pcall(function()
        Break = ((A.Name == "RPG_Explosion_Long" or A.Name == "RPG_Explosion_Short"))
    end)
end)
   end,
})
--Melee Aura Start.
local meleeaurahitpart = "Head"
local range = 30
local togglemeleeaura = false
local AimlockToggle = Tab:CreateToggle({
    Name = "Melee aura",
    CurrentValue = false,
    Flag = "", 
    Callback = function(Value)
    togglemeleeaura = Value

    local function GetClosest()
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local Character = LocalPlayer.Character
        local HitPartTarget = Character and Character:FindFirstChild(meleeaurahitpart)
        if not (Character or HumanoidRootPart) then return end

        local TargetDistance = math.huge
        local Target

        for i,v in pairs(Players:GetPlayers()) do
            if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild(meleeaurahitpart) then
                local TargetHRP = v.Character:FindFirstChild(meleeaurahitpart)
                local mag = (HitPartTarget.Position - TargetHRP.Position).magnitude
                if mag < TargetDistance then
                    TargetDistance = mag
                    Target = v
                end
            end
        end
        if TargetDistance <= range then
            return Target
        else
            return nil
        end
    end

    if Value then
        meleeaurarunservice = game:GetService("RunService").RenderStepped:Connect(function()
            if togglemeleeaura and Value then
                for _, item in pairs(game:GetService("Players").LocalPlayer.Character:GetChildren()) do
                    if item then
                        if item:IsA("Tool") then
                            if item.Name ~= "Fists" then
                                if item.Name ~= "Sledgehammer" then
                                    if item:FindFirstChild("WeaponHandle") then
                                        if item:FindFirstChild("WeaponHandle"):FindFirstChild("Swing1") or item:FindFirstChild("WeaponHandle"):FindFirstChild("Swing2") then
                                            local HitTarget = GetClosest()
                                            if HitTarget then
                                                if HitTarget.Character then
                                                    if HitTarget.Character:FindFirstChild("Humanoid") and HitTarget.Character:FindFirstChild(meleeaurahitpart) then
                                                        if HitTarget.Character:FindFirstChild("Humanoid").Health > 0 then
                                                            for _, a in pairs(item.WeaponHandle:GetChildren()) do
                                                                if a then
                                                                    if a.Name == "DmgPoint" then
                                                                        local part = HitTarget.Character:FindFirstChild(meleeaurahitpart)
                                                                        a.CFrame = CFrame.new(0, 0, 0)
                                                                        local x = part.Position.X + math.random(-part.Size.X,part.Size.X)/10
                                                                        local y = part.Position.Y + math.random(-part.Size.Y,part.Size.Y)/10
                                                                        local z = part.Position.Z + math.random(-part.Size.Z,part.Size.Z)/10
                                                                        a.WorldCFrame = CFrame.new(x, y, z) * CFrame.new(0, 0.54, 0)
                                                                    end
                                                                end
                                                            end 
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                else
                                    if item:FindFirstChild("Handle") then
                                        if item:FindFirstChild("Handle"):FindFirstChild("Swing1") or item:FindFirstChild("Handle"):FindFirstChild("Swing2") then
                                            local HitTarget = GetClosest()
                                            if HitTarget then
                                                if HitTarget.Character then
                                                    if HitTarget.Character:FindFirstChild("Humanoid") and HitTarget.Character:FindFirstChild(meleeaurahitpart) then
                                                        if HitTarget.Character:FindFirstChild("Humanoid").Health > 0 then
                                                            for _, a in pairs(item.Handle:GetChildren()) do
                                                                if a then
                                                                    if a.Name == "DmgPoint" then
                                                                        local part = HitTarget.Character:FindFirstChild(meleeaurahitpart)
                                                                        a.CFrame = CFrame.new(0, 0, 0)
                                                                        local x = part.Position.X + math.random(-part.Size.X,part.Size.X)/10
                                                                        local y = part.Position.Y + math.random(-part.Size.Y,part.Size.Y)/10
                                                                        local z = part.Position.Z + math.random(-part.Size.Z,part.Size.Z)/10
                                                                        a.WorldCFrame = CFrame.new(x, y, z) * CFrame.new(0, 0.4, 0)
                                                                    end
                                                                end
                                                            end 
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            else
                                for _, arms in pairs(game:GetService("Players").LocalPlayer.Character:GetChildren()) do
                                    if arms then
                                        if arms.Name == "Left Arm" or arms.Name == "Right Arm" then 
                                            if arms then
                                                local HitTarget = GetClosest()
                                                if HitTarget then
                                                    if HitTarget.Character then
                                                        if HitTarget.Character:FindFirstChild("Humanoid") and HitTarget.Character:FindFirstChild(meleeaurahitpart) then
                                                            if HitTarget.Character:FindFirstChild("Humanoid").Health > 0 then
                                                                if arms then
                                                                    for _, a in pairs(arms:GetChildren()) do
                                                                        if a then
                                                                            if a.Name == "DmgPoint" then
                                                                                local part = HitTarget.Character:FindFirstChild(meleeaurahitpart)
                                                                                a.CFrame = CFrame.new(0, 0, 0)
                                                                                local x = part.Position.X + math.random(-part.Size.X,part.Size.X)/10
                                                                                local y = part.Position.Y + math.random(-part.Size.Y,part.Size.Y)/10
                                                                                local z = part.Position.Z + math.random(-part.Size.Z,part.Size.Z)/10
                                                                                a.WorldCFrame = CFrame.new(x, y, z) * CFrame.new(0, 0.5, 0)
                                                                                -- a.WorldCFrame = HitTarget.Character:FindFirstChild(meleeaurahitpart).CFrame * CFrame.new(0, 0, 0)
                                                                            end
                                                                        end
                                                                    end 
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            else
                if meleeaurarunservice then
                    meleeaurarunservice:Disconnect()
                end
            end
        end)
    else
        if not Value and not togglemeleeaura then 
            if meleeaurarunservice then
                meleeaurarunservice:Disconnect()
            end
        end
    end
end,
})
local Button = Tab:CreateButton({
   Name = "Fling",
   Callback = function()
 loadstring(game:HttpGet'https://raw.githubusercontent.com/sauga77kjk/RobloxExploitRepository/main/TouchFLING')()
   end,
})



-- Function to apply changes to a door model
local function applyDoorChanges(door)
    -- Keep track of the original materials of the parts
    local originalMaterials = {}

    -- Iterate through all descendants of the model
    for _, part in ipairs(door:GetDescendants()) do
        if part:IsA("BasePart") then
            -- Store the original material before changing it
            if not originalMaterials[part] then
                originalMaterials[part] = part.Material
            end

            -- Set the transparency of each part to 0.5 (semi-transparent)
            part.Transparency = 0.5
            -- Set the material to SmoothPlastic to better handle transparency
            part.Material = Enum.Material.SmoothPlastic
            -- Disable collisions for each part
            part.CanCollide = false

            -- Make the DFrame parts invisible
            if part.Name == "DFrame" then
                part.Transparency = 1
                part.CanCollide = false -- Ensure no collisions
            end
        end
    end

    -- Restore the original material of the parts
    for part, material in pairs(originalMaterials) do
        if part and part:IsA("BasePart") then
            part.Material = material
        end
    end
end

-- Function to handle newly added doors
local function onNewDoorAdded(newDoor)
    if newDoor:IsA("Model") then
        applyDoorChanges(newDoor)
    end
end

-- Create the button and define its behavior
local Button = Tab:CreateButton({
    Name = "Anti Doors",  -- Set the button text to "Anti Doors"
    Callback = function()
        -- Access the Doors folder within the Map
        local doorsFolder = game.Workspace.Map:FindFirstChild("Doors")

        -- Check if the Doors folder exists
        if doorsFolder then
            -- Apply changes to existing doors
            for _, door in ipairs(doorsFolder:GetChildren()) do
                if door:IsA("Model") then
                    applyDoorChanges(door)
                end
            end

            -- Connect a function to handle new doors being added
            doorsFolder.ChildAdded:Connect(onNewDoorAdded)

            print("Existing and new doors will now be semi-transparent, non-collidable, and DFrame parts will be invisible.")
        else
            print("No Doors folder found in Map.")
        end
    end,
})
       
-- Premium
local Tab = Window:CreateTab("Premium", nil) -- Title, Image
local PremiumButton = Tab:CreateButton({
   Name = "NoClip",
   Callback = function()
   local Noclip = nil
local Clip = nil

function noclip()
	Clip = false
	local function Nocl()
		if Clip == false and game.Players.LocalPlayer.Character ~= nil then
			for _,v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
				if v:IsA('BasePart') and v.CanCollide and v.Name ~= floatName then
					v.CanCollide = false
				end
			end
		end
		wait(0.21) -- basic optimization
	end
	Noclip = game:GetService('RunService').Stepped:Connect(Nocl)
end

function clip()
	if Noclip then Noclip:Disconnect() end
	Clip = true
end

noclip() -- to toggle noclip() and clip()
   end,
})

local Tab = Window:CreateTab("Credits", nil) -- Title, Image
local CreditsSection = Tab:CreateSection("Credits")
local Button = Tab:CreateButton({
   Name = "Discord Server",
   Callback = function()
   setclipbord("https://discord.gg/NNSggZ67GZ")
   end,
})
